
[[_getting_started_console_example]]
= Console Example
:console-swing-groovy: {rootdir}/samples/console-swing-groovy

== Creating a Project

The first is to get Lazybones installed on your system. The easiest way to achieve
this goal is to install http://gvmtool.net[GVM] first

[source]
----
$ curl -s get.gvmtool.net | bash
----

Install the latest version of Lazybones with the following command

[source]
----
$ gvm install lazybones
----

Next, add the official Griffon Lazybones templates repository to your Lazybones
configuration. Edit +$USER_HOME/.lazybones/config.groovy+ and paste the following
content

.$USER_HOME/.lazybones/config.groovy
[source,groovy]
----
bintrayRepositories = [
    "griffon/griffon-lazybones-templates",
    "pledbrook/lazybones-templates"
]
----

We're now ready to create the project. You can list all available templates with
the following command

[source]
----
$ lazybones list
Available templates in griffon/griffon-lazybones-templates:

    griffon-lanterna-java
    griffon-swing-groovy
    griffon-javafx-groovy
    griffon-javafx-java
    griffon-swing-java
    griffon-pivot-java
    griffon-pivot-groovy
    griffon-plugin-single
    griffon-lanterna-groovy
----

Alright, let's create an simple project using Swing as main UI toolkit and Groovy
as main language

[source]
----
$ lazybones create griffon-swing-groovy console
Creating project from template griffon-swing-groovy (latest) in 'console'
Define value for 'group' [org.example]: console
Define value for 'version' [0.1.0-SNAPSHOT]:
Define value for 'package' [console]:
Define value for 'griffonVersion' [2.0.0.BETA]:
----

== Project Layout

Take a moment to familiarize yourself with the standard Griffon project layout.
Every Griffon project shares the same layout, making it easy to dive in as artifacts
are located in specific directories according to their responsibilities and behavior.

[source]
----
console
├── griffon-app
│   ├── conf
│   ├── controllers
│   ├── i18n
│   ├── lifecycle
│   ├── models
│   ├── resources
│   ├── services
│   └── views
└── src
    ├── main
    │   ├── groovy
    │   └── resources
    └── test
        ├── groovy
        └── resources
----

To give you an idea of what we're aiming at with this example here's an screenshot
of the finished application running. A small Groovy script has been executed, you
can see the result on the bottom right side

image::console-swing-groovy.png[Swing, 50%, 50%, align="center"]

=== Gradle

The following listing shows the Gradle build file generated by the Lazybones template

[[gradle-build-file]]
.build.gradle
[source,groovy]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/build.gradle.txt[]
----
<1> Project properties
<2> Apply +groovy+ plugin for compiling Groovy sources
<3> Apply +application+ plugin for running and packaging
<4> APT will run automatically
<5> Standard Griffon project layout
<6> Needed for compile-time generation of metadata
<7> Groovy specific support for Griffon
<8> Toolkit specific support
<9> An implementation of JSR 330 is required
<10> Groovy SwingBuilder
<11> Logging framework
<12> Log4j to Slf4j connector
<13> Test dependencies

Alright, let's get started with the code. We'll visit the Model first.

=== Model

The model for this application is simple: it contains properties that hold the script to be
evaluated and the results of the evaluation. Make sure you paste the following code into
+griffon-app/models/console/ConsoleModel.groovy+.

.griffon-app/models/console/ConsoleModel.groovy
[source,groovy]
----
include::{console-swing-groovy}/griffon-app/models/console/ConsoleModel.groovy[lines=16..-1]
----
<1> Holds the script's text
<2> Holds the result of the script's execution
<3> Enable/disable flag

Griffon Models are *_not_* domain classes like the ones you find in Grails; they're more akin
to presentation models, and as such, they're used to transfer data between Views and Controllers.

=== Controller

The controller is also trivial: throw the contents of the script from the model at an +Evaluator+,
then store the result back into the model. Make sure you paste the following code into
+griffon-app/controllers/console/ConsoleController.groovy+.

.griffon-app/controllers/console/ConsoleController.groovy
[source,groovy]
----
include::{console-swing-groovy}/griffon-app/controllers/console/ConsoleController.groovy[lines=16..-1]
----
<1> MVC member injected by +{link_mvc_group_manager}+
<2> Injected by JSR 330
<3> Controller action; automatically executed off the UI thread
<4> Evaluate the script
<5> Write back result to Model

The Griffon framework will inject references to the other portions of the MVC triad if fields
named +model+, +view+, and +controller+ are present in the Model, Controller or View. This allows
us to access the view widgets and the model data if needed. Any other class members annotated with
+@Inject+ participate in dependency injection as laid out by JSR 330, in this case the controller
will get an instance of +Evaluator+ if a suitable implementation is bound.

The +executeScript+ [conum,data-value=3]_3_ method will be used later in the View in combination
with a button. You may notice that there's no explicit threading management. All Swing developers
know they must obey the Swing Rule: long running computations must run outside of the EDT; all UI
components should be queried/modified inside the EDT. It turns out Griffon is aware of this rule,
making sure an action is called outside of the EDT by default, all bindings made to UI components
via the model will be updated inside the EDT [conum,data-value=5]_5_. We'll setup the bindings in
the next listing.

We must create a +{link_module}+ in order to bind +Evaluator+.
These are the required class definitions

.src/main/groovy/console/Evaluator.groovy
[source,groovy]
----
include::{console-swing-groovy}/src/main/groovy/console/Evaluator.groovy[lines=16..-1]
----

.src/main/groovy/console/GroovyShellEvaluator.groovy
[source,groovy]
----
include::{console-swing-groovy}/src/main/groovy/console/GroovyShellEvaluator.groovy[lines=16..-1]
----

.src/main/groovy/console/ApplicationModule.groovy
[source,groovy]
----
include::{console-swing-groovy}/src/main/groovy/console/ApplicationModule.groovy[lines=16..-1]
----
<1> Binding definition
<2> Overriding an existing binding
<3> Loaded after 'swing' module

Modules can define several bindings, even override existing bindings. In our particular
case we defined a binding [conum,data-value=1]_1_ for +Evaluator+ and override a
a binding [conum,data-value=2]_2_ for +SwingWindowDisplayHandler+. The latter is
supplied by the +swing+ module thus me must mark it as a dependency [conum,data-value=3]_3_
in our module definition. The implementation of our custom +SwingWindowDisplayHandler+
is quite trivial, as shown by the following snippet

.src/main/groovy/console/CenteringWindowDisplayHandler.groovy
[source,groovy]
----
include::{console-swing-groovy}/src/main/groovy/console/CenteringWindowDisplayHandler.groovy[lines=16..-1]
----

This handler is only concerned with centering the window on the screen before showing it.

=== View

The view classes contain the visual components for your application. Please paste the following code
into +griffon-app/views/console/ConsoleView.groovy+.

.griffon-app/views/console/ConsoleView.groovy
[source,groovy]
----
include::{console-swing-groovy}/griffon-app/views/console/ConsoleView.groovy[lines=16..-1]
----
<1> MVC member injected by +{link_mvc_group_manager}+
<2> Bind enabled state from model
<3> Bind script source to model
<4> Apply controller action by convention
<5> Bind script result from model

The View contains a fairly straightforward SwingBuilder script. Griffon will execute these groovy
scripts in context of it's +{link_composite_builder}+.

== Running the application

Running the application requires you to execute the +run+ task

[source]
----
$ gradle run
----

== Testing

.src/test/groovy/console/ConsoleControllerTest.groovy
[source,groovy]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/src/test/groovy/console/ConsoleControllerTest.groovy[lines=16..-1]
----
<1> Indicate class under test
<2> Injected by +GriffonUnitRule+ given [conum,data-value=1]_1_
<3> Injected by +GriffonUnitRule+ via JSR 330
<4> Instantiates and configures a +GriffonAplication+ for testing
<5> Setup collaborators
<6> Stimulus
<7> Validate after waiting 2 seconds at most

Running tests requires executing the +test+ task

[source]
----
$ gradle test
----

