= Console Example
:console-swing-groovy: {rootdir}/samples/console-swing-groovy

== Creating a Project

The first task at hand is deciding which build tool to use. Both Gradle and Maven are popular choices.
The Griffon team recommends using Gradle as it delivers a much better experience than Maven or even Ant+Ivy.
The following sections show sample build files for Gradle, Maven and Ant with Groovy as the target language. You may
use Java instead if you want of course, however Groovy is more expressive with less clutter, thus lending itself
for a better learning experience. But don't worry if you're nor familiar with Groovy, this guide includes further
examples where Java is the main language.

=== Gradle

The following listing shows a typical Gradle build file for a Griffon project

[[gradle-build-file]]
.build.gradle
[source,groovy]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/build.gradle.txt[]
----
<1> Project properties
<2> Apply +groovy+ plugin for compiling Groovy sources
<3> Apply +application+ plugin for running and packaging
<4> APT will run automatically
<5> Standard Griffon project layout
<6> Needed for compile-time generation of metadata
<7> Groovy specific support for Griffon
<8> Toolkit specific support
<9> Groovy SwingBuilder
<10> An implementation of JSR 330 is required
<11> Logging framework
<12> Log4j to Slf4j connector

=== Maven

Maven is another popular choice among developers. The following listing displays the minimal setup that's
required to build a Griffon application with Maven.

.pom.xml
[source,xml]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/pom.xml.txt[]
----
<1> Project properties
<2> Apply +groovy+ plugin for compiling Groovy sources
<3> Apply +application+ plugin for running and packaging
<4> APT required for compile-time generation of metadata
<5> Standard Griffon project layout
<6> Needed for compile-time generation of metadata
<7> Groovy specific support for Griffon
<8> Toolkit specific support
<9> Groovy SwingBuilder
<10> An implementation of JSR 330 is required
<11> Logging framework
<12> Log4j to Slf4j connector

Notice the similarities with the <<gradle-build-file,gradle>> build file as marked with each one
of the 12 callouts.

=== Ant

Ant build files are simple in nature however their complexity max grow exponentially as more
behavior is needed. The following shows a very basic Ant build file that assumes all dependencies
are located relative to the project

.build.xml
[source,xml]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/build.xml.txt[]
----
<1> Project properties
<2> Classpath definitions
<3> Load +groovy+ task for compiling Groovy sources
<4> Standard Griffon project layout
<5> Run the application

These are the dependencies as required by this project

.build
include::{projectdir}/build/generated-dependencies/build.adoc[]

.provided
include::{projectdir}/build/generated-dependencies/provided.adoc[]

.compile
include::{projectdir}/build/generated-dependencies/compile.adoc[]

.runtime
include::{projectdir}/build/generated-dependencies/runtime.adoc[]

TODO: insert section on Lazybones templates

== Project Layout

Take a moment to familiarize yourself with the standard Griffon project layout. Every Griffon
project shares the same layout, making it easy to dive in as artifacts are located in specific
directories according to their responsibilities and behavior.

[source]
----
console
+- griffon-app
|  +- conf
|  +- controllers
|  +- i18n
|  +- lifecycle
|  +- models
|  +- resources
|  +- services
|  +- views
|
+- src
   +- main
      +- groovy
      +- resources
----

=== Model

The model for this application is simple: it contains properties that hold the script to be
evaluated and the results of the evaluation. Make sure you paste the following code into
+griffon-app/models/console/ConsoleModel.groovy+.

.griffon-app/models/console/ConsoleModel.groovy
[source,groovy]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/griffon-app/models/console/ConsoleModel.groovy[]
----
<1> Holds the script's text
<2> Holds the result of the script's execution
<3> Enable/disable flag

Griffon Models are *_not_* domain classes like the ones you find in Grails; they're more akin
to presentation models, and as such, they're used to transfer data between Views and Controllers.

=== Controller

The controller is also trivial: throw the contents of the script from the model at a Groovy shell,
then store the result back into the model. Make sure you paste the following code into
+griffon-app/controllers/console/ConsoleController.groovy+.

.griffon-app/controllers/console/ConsoleController.groovy
[source,groovy]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/griffon-app/controllers/console/ConsoleController.groovy[]
----
<1> MVC member injected by +link:api/griffon/core/mvc/MVCGroupManager.html[MVCGroupManager]+
<2> Controller action; automatically executed off the UI thread
<3> Evaluate the script
<4> Write back result to Model

The Griffon framework will inject references to the other portions of the MVC triad if fields
named +model+, +view+, and +controller+ are present in the Model, Controller or View. This allows
us to access the view widgets and the model data if needed.

The +executeScript+ [conum,data-value=2]_2_ method will be used later in the View in combination
with a button. You may notice that there's no explicit threading management. All Swing developers
know they must obey the Swing Rule: long running computations must run outside of the EDT; all UI
components should be queried/modified inside the EDT. It turns out Griffon is aware of this rule,
making sure an action is called outside of the EDT by default, all bindings made to UI components
via the model will be updated inside the EDT [conum,data-value=4]_4_. We'll setup the bindings in
the next listing.

=== View

The view classes contain the visual components for your application. Please paste the following code
into +griffon-app/views/console/ConsoleView.groovy+.

.griffon-app/views/console/ConsoleView.groovy
[source,groovy]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/griffon-app/views/console/ConsoleView.groovy[]
----
<1> MVC member injected by +link:api/griffon/core/mvc/MVCGroupManager.html[MVCGroupManager]+
<2> Bind enabled state from model
<3> Bind script source to model
<4> Apply controller action by convention
<5> Bind script result from model

The View contains a fairly straightforward SwingBuilder script. Griffon will execute these groovy
scripts in context of it's +link:api/griffon/util/CompositeBuilder[CompositeBuilder]+.

== Running the application

Running the application requires you to execute a build tool specific command

.gradle
[source]
----
gradle run
----

.maven
[source]
----
mvn compile exec:java
----

.ant
[source]
----
ant compile run
----
