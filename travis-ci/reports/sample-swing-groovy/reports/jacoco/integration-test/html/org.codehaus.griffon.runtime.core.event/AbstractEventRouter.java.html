<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractEventRouter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sample-swing-groovy</a> &gt; <a href="index.source.html" class="el_package">org.codehaus.griffon.runtime.core.event</a> &gt; <span class="el_source">AbstractEventRouter.java</span></div><h1>AbstractEventRouter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.codehaus.griffon.runtime.core.event;

import griffon.core.CallableWithArgs;
import griffon.core.RunnableWithArgs;
import griffon.core.event.Event;
import griffon.core.event.EventRouter;
import griffon.util.GriffonClassUtils;
import griffon.util.MethodDescriptor;
import griffon.util.MethodUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import static griffon.util.GriffonClassUtils.convertToTypeArray;
import static griffon.util.GriffonNameUtils.capitalize;
import static griffon.util.GriffonNameUtils.requireNonBlank;
import static java.util.Arrays.asList;
import static java.util.Collections.EMPTY_LIST;
import static java.util.Collections.unmodifiableCollection;
import static java.util.Objects.requireNonNull;

/**
 * @author Andres Almiray
 */
<span class="fc" id="L51">public abstract class AbstractEventRouter implements EventRouter {</span>
<span class="fc" id="L52">    protected static final Object[] LOCK = new Object[0];</span>
    private static final String ERROR_EVENT_NAME_BLANK = &quot;Argument 'eventName' must not be blank&quot;;
    private static final String ERROR_EVENT_HANDLER_BLANK = &quot;Argument 'eventHandler' must not be blank&quot;;
    private static final String ERROR_MODE_BLANK = &quot;Argument 'mode' must not be blank&quot;;
    private static final String ERROR_LISTENER_NULL = &quot;Argument 'listener' must not be null&quot;;
    private static final String ERROR_EVENT_CLASS_NULL = &quot;Argument 'eventClass' must not be null&quot;;
    private static final String ERROR_EVENT_NULL = &quot;Argument 'event' must not be null&quot;;
    private static final String ERROR_CALLABLE_NULL = &quot;Argument 'callable' must not be null&quot;;
    private static final String ERROR_RUNNABLE_NULL = &quot;Argument 'runnable' must not be null&quot;;
    private static final String ERROR_PARAMS_NULL = &quot;Argument 'params' must not be null&quot;;
    private static final String ERROR_INSTANCE_NULL = &quot;Argument 'instance' must not be null&quot;;
    private static final String ERROR_OWNER_NULL = &quot;Argument 'owner' must not be null&quot;;
<span class="fc" id="L64">    private static final Logger LOG = LoggerFactory.getLogger(AbstractEventRouter.class);</span>
<span class="fc" id="L65">    protected final Map&lt;String, List&lt;Object&gt;&gt; instanceListeners = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L66">    protected final Map&lt;String, List&lt;Object&gt;&gt; functionalListeners = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L67">    private final MethodCache methodCache = new MethodCache();</span>
<span class="fc" id="L68">    private boolean enabled = true;</span>

    @Override
    public boolean isEventPublishingEnabled() {
<span class="fc" id="L72">        synchronized (LOCK) {</span>
<span class="fc" id="L73">            return this.enabled;</span>
<span class="nc" id="L74">        }</span>
    }

    @Override
    public void setEventPublishingEnabled(boolean enabled) {
<span class="fc" id="L79">        synchronized (LOCK) {</span>
<span class="fc" id="L80">            this.enabled = enabled;</span>
<span class="pc" id="L81">        }</span>
<span class="fc" id="L82">    }</span>

    @Override
    public void publishEvent(@Nonnull String eventName) {
<span class="nc" id="L86">        publishEvent(eventName, EMPTY_LIST);</span>
<span class="nc" id="L87">    }</span>

    @Override
    public void publishEvent(@Nonnull String eventName, @Nullable List&lt;?&gt; params) {
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (!isEventPublishingEnabled()) return;</span>
<span class="fc" id="L92">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (params == null) params = EMPTY_LIST;</span>
<span class="fc" id="L94">        buildPublisher(eventName, params, &quot;synchronously&quot;).run();</span>
<span class="fc" id="L95">    }</span>

    @Override
    public void publishEventOutsideUI(@Nonnull String eventName) {
<span class="nc" id="L99">        publishEventOutsideUI(eventName, EMPTY_LIST);</span>
<span class="nc" id="L100">    }</span>

    @Override
    public void publishEventOutsideUI(@Nonnull String eventName, @Nullable List&lt;?&gt; params) {
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (!isEventPublishingEnabled()) return;</span>
<span class="nc" id="L105">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (params == null) params = EMPTY_LIST;</span>
<span class="nc" id="L107">        final Runnable publisher = buildPublisher(eventName, params, &quot;outside UI&quot;);</span>
<span class="nc" id="L108">        doPublishOutsideUI(publisher);</span>
<span class="nc" id="L109">    }</span>

    protected abstract void doPublishOutsideUI(@Nonnull Runnable publisher);

    @Override
    public void publishEventAsync(@Nonnull String eventName) {
<span class="nc" id="L115">        publishEventAsync(eventName, EMPTY_LIST);</span>
<span class="nc" id="L116">    }</span>

    @Override
    public void publishEventAsync(@Nonnull String eventName, @Nullable List&lt;?&gt; params) {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (!isEventPublishingEnabled()) return;</span>
<span class="nc" id="L121">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (params == null) params = EMPTY_LIST;</span>
<span class="nc" id="L123">        final Runnable publisher = buildPublisher(eventName, params, &quot;asynchronously&quot;);</span>
<span class="nc" id="L124">        doPublishAsync(publisher);</span>
<span class="nc" id="L125">    }</span>

    protected abstract void doPublishAsync(@Nonnull Runnable publisher);

    @Override
    public void publishEvent(@Nonnull Event event) {
<span class="nc" id="L131">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="nc" id="L132">        publishEvent(event.getClass().getSimpleName(), asList(event));</span>
<span class="nc" id="L133">    }</span>

    @Override
    public void publishEventOutsideUI(@Nonnull Event event) {
<span class="nc" id="L137">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="nc" id="L138">        publishEventOutsideUI(event.getClass().getSimpleName(), asList(event));</span>
<span class="nc" id="L139">    }</span>

    @Override
    public void publishEventAsync(@Nonnull Event event) {
<span class="nc" id="L143">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="nc" id="L144">        publishEventAsync(event.getClass().getSimpleName(), asList(event));</span>
<span class="nc" id="L145">    }</span>

    @Override
    public &lt;E extends Event&gt; void removeEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="nc" id="L149">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="nc" id="L150">        removeEventListener(eventClass.getSimpleName(), listener);</span>
<span class="nc" id="L151">    }</span>

    @Override
    public &lt;E extends Event&gt; void removeEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull RunnableWithArgs listener) {
<span class="nc" id="L155">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="nc" id="L156">        removeEventListener(eventClass.getSimpleName(), listener);</span>
<span class="nc" id="L157">    }</span>

    protected void fireEvent(@Nonnull RunnableWithArgs runnable, @Nonnull List&lt;?&gt; params) {
<span class="fc" id="L160">        requireNonNull(runnable, ERROR_RUNNABLE_NULL);</span>
<span class="fc" id="L161">        requireNonNull(params, ERROR_PARAMS_NULL);</span>
<span class="fc" id="L162">        runnable.run(asArray(params));</span>
<span class="fc" id="L163">    }</span>

    protected void fireEvent(@Nonnull CallableWithArgs&lt;?&gt; callable, @Nonnull List&lt;?&gt; params) {
<span class="nc" id="L166">        requireNonNull(callable, ERROR_CALLABLE_NULL);</span>
<span class="nc" id="L167">        requireNonNull(params, ERROR_PARAMS_NULL);</span>
<span class="nc" id="L168">        callable.call(asArray(params));</span>
<span class="nc" id="L169">    }</span>

    protected void fireEvent(@Nonnull Object instance, @Nonnull String eventHandler, @Nonnull List&lt;?&gt; params) {
<span class="fc" id="L172">        requireNonNull(instance, ERROR_INSTANCE_NULL);</span>
<span class="fc" id="L173">        requireNonBlank(eventHandler, ERROR_EVENT_HANDLER_BLANK);</span>
<span class="fc" id="L174">        requireNonNull(params, ERROR_PARAMS_NULL);</span>

<span class="fc" id="L176">        Class[] argTypes = convertToTypeArray(asArray(params));</span>
<span class="fc" id="L177">        MethodDescriptor target = new MethodDescriptor(eventHandler, argTypes);</span>
<span class="fc" id="L178">        Method method = methodCache.findMatchingMethodFor(instance.getClass(), target);</span>

<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (method != null) {</span>
<span class="fc" id="L181">            MethodUtils.invokeSafe(method, instance, asArray(params));</span>
        }
<span class="fc" id="L183">    }</span>

    @Override
    public &lt;E extends Event&gt; void addEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="nc" id="L187">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="nc" id="L188">        addEventListener(eventClass.getSimpleName(), listener);</span>
<span class="nc" id="L189">    }</span>

    @Override
    public &lt;E extends Event&gt; void addEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull RunnableWithArgs listener) {
<span class="nc" id="L193">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="nc" id="L194">        addEventListener(eventClass.getSimpleName(), listener);</span>
<span class="nc" id="L195">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void addEventListener(@Nonnull Object listener) {
<span class="fc" id="L200">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (listener instanceof RunnableWithArgs) {</span>
<span class="nc" id="L202">            throw new IllegalArgumentException(&quot;Cannot add an event listener of type &quot; + RunnableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (listener instanceof CallableWithArgs) {</span>
<span class="nc" id="L206">            throw new IllegalArgumentException(&quot;Cannot add an event listener of type &quot; + CallableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }

<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (listener instanceof Map) {</span>
<span class="nc" id="L211">            addEventListener((Map) listener);</span>
<span class="nc" id="L212">            return;</span>
        }

<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (!methodCache.isEventListener(listener.getClass())) {</span>
<span class="fc" id="L216">            return;</span>
        }

<span class="fc" id="L219">        boolean added = false;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (String eventName : methodCache.fetchMethodMetadata(listener.getClass()).keySet()) {</span>
<span class="fc" id="L221">            eventName = eventName.substring(2); // cut off &quot;on&quot; from the name</span>
<span class="fc" id="L222">            List&lt;Object&gt; instances = instanceListeners.get(eventName);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (instances == null) {</span>
<span class="fc" id="L224">                instances = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L225">                instanceListeners.put(eventName, instances);</span>
            }
<span class="fc" id="L227">            synchronized (instances) {</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                if (!instances.contains(listener)) {</span>
<span class="fc" id="L229">                    added = true;</span>
<span class="fc" id="L230">                    instances.add(listener);</span>
                }
<span class="pc" id="L232">            }</span>
<span class="fc" id="L233">        }</span>

<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (added) {</span>
            try {
<span class="fc" id="L237">                LOG.debug(&quot;Adding listener {}&quot;, listener);</span>
<span class="nc" id="L238">            } catch (UnsupportedOperationException uoe) {</span>
<span class="nc" id="L239">                LOG.debug(&quot;Adding listener {}&quot;, listener.getClass().getName());</span>
<span class="fc" id="L240">            }</span>
        }
<span class="fc" id="L242">    }</span>

    @Override
    public void addEventListener(@Nonnull Map&lt;String, Object&gt; listener) {
<span class="nc" id="L246">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : listener.entrySet()) {</span>
<span class="nc" id="L248">            Object eventHandler = entry.getValue();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (eventHandler instanceof RunnableWithArgs) {</span>
<span class="nc" id="L250">                addEventListener(entry.getKey(), (RunnableWithArgs) eventHandler);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            } else if (eventHandler instanceof CallableWithArgs) {</span>
<span class="nc" id="L252">                addEventListener(entry.getKey(), (CallableWithArgs) eventHandler);</span>
            } else {
<span class="nc" id="L254">                throw new IllegalArgumentException(&quot;Unsupported functional event listener &quot; + eventHandler);</span>
            }
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void removeEventListener(@Nonnull Object listener) {
<span class="fc" id="L262">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (listener instanceof RunnableWithArgs) {</span>
<span class="nc" id="L264">            throw new IllegalArgumentException(&quot;Cannot remove an event listener of type &quot; + RunnableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (listener instanceof CallableWithArgs) {</span>
<span class="nc" id="L268">            throw new IllegalArgumentException(&quot;Cannot remove an event listener of type &quot; + CallableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (listener instanceof Map) {</span>
<span class="nc" id="L273">            removeEventListener((Map) listener);</span>
<span class="nc" id="L274">            return;</span>
        }

<span class="fc" id="L277">        boolean removed = false;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        for (String eventName : methodCache.fetchMethodMetadata(listener.getClass()).keySet()) {</span>
<span class="nc" id="L279">            eventName = eventName.substring(2); // cut off &quot;on&quot; from the name</span>
<span class="nc" id="L280">            List&lt;Object&gt; instances = instanceListeners.get(eventName);</span>
<span class="nc bnc" id="L281" title="All 4 branches missed.">            if (instances != null &amp;&amp; instances.contains(listener)) {</span>
<span class="nc" id="L282">                instances.remove(listener);</span>
<span class="nc" id="L283">                removed = true;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (instances.isEmpty()) {</span>
<span class="nc" id="L285">                    instanceListeners.remove(eventName);</span>
                }
            }
<span class="nc" id="L288">        }</span>

<span class="fc" id="L290">        boolean nestedRemoved = removeNestedListeners(listener);</span>

<span class="pc bpc" id="L292" title="2 of 4 branches missed.">        if (removed || nestedRemoved) {</span>
            try {
<span class="nc" id="L294">                LOG.debug(&quot;Removing listener {}&quot;, listener);</span>
<span class="nc" id="L295">            } catch (UnsupportedOperationException uoe) {</span>
<span class="nc" id="L296">                LOG.debug(&quot;Removing listener {}&quot;, listener.getClass().getName());</span>
<span class="nc" id="L297">            }</span>
        }
<span class="fc" id="L299">    }</span>

    @Override
    public void removeEventListener(@Nonnull Map&lt;String, Object&gt; listener) {
<span class="nc" id="L303">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : listener.entrySet()) {</span>
<span class="nc" id="L305">            Object eventHandler = entry.getValue();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (eventHandler instanceof RunnableWithArgs) {</span>
<span class="nc" id="L307">                removeEventListener(entry.getKey(), (RunnableWithArgs) eventHandler);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            } else if (eventHandler instanceof CallableWithArgs) {</span>
<span class="nc" id="L309">                removeEventListener(entry.getKey(), (CallableWithArgs) eventHandler);</span>
            } else {
<span class="nc" id="L311">                throw new IllegalArgumentException(&quot;Unsupported functional event listener &quot; + eventHandler);</span>
            }
<span class="nc" id="L313">        }</span>
<span class="nc" id="L314">    }</span>

    @Override
    public void addEventListener(@Nonnull String eventName, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="nc" id="L318">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="nc" id="L319">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="nc" id="L320">        synchronized (functionalListeners) {</span>
<span class="nc" id="L321">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (list == null) {</span>
<span class="nc" id="L323">                list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L324">                functionalListeners.put(capitalize(eventName), list);</span>
            }
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (list.contains(listener)) return;</span>
<span class="nc" id="L327">            LOG.debug(&quot;Adding listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="nc" id="L328">            list.add(listener);</span>
<span class="nc" id="L329">        }</span>
<span class="nc" id="L330">    }</span>

    @Override
    public void addEventListener(@Nonnull String eventName, @Nonnull RunnableWithArgs listener) {
<span class="fc" id="L334">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="fc" id="L335">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L336">        synchronized (functionalListeners) {</span>
<span class="fc" id="L337">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L339">                list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L340">                functionalListeners.put(capitalize(eventName), list);</span>
            }
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (list.contains(listener)) return;</span>
<span class="fc" id="L343">            LOG.debug(&quot;Adding listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="fc" id="L344">            list.add(listener);</span>
<span class="pc" id="L345">        }</span>
<span class="fc" id="L346">    }</span>

    @Override
    public void removeEventListener(@Nonnull String eventName, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="nc" id="L350">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="nc" id="L351">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="nc" id="L352">        synchronized (functionalListeners) {</span>
<span class="nc" id="L353">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (list != null) {</span>
<span class="nc" id="L355">                LOG.debug(&quot;Removing listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="nc" id="L356">                list.remove(listener);</span>
            }
<span class="nc" id="L358">        }</span>
<span class="nc" id="L359">    }</span>

    @Override
    public void removeEventListener(@Nonnull String eventName, @Nonnull RunnableWithArgs listener) {
<span class="nc" id="L363">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="nc" id="L364">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="nc" id="L365">        synchronized (functionalListeners) {</span>
<span class="nc" id="L366">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (list != null) {</span>
<span class="nc" id="L368">                LOG.debug(&quot;Removing listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="nc" id="L369">                list.remove(listener);</span>
            }
<span class="nc" id="L371">        }</span>
<span class="nc" id="L372">    }</span>

    @Nonnull
    @Override
    public Collection&lt;Object&gt; getEventListeners() {
<span class="nc" id="L377">        List&lt;Object&gt; listeners = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L378">        synchronized (instanceListeners) {</span>
<span class="nc" id="L379">            Set&lt;Object&gt; instances = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            for (List&lt;Object&gt; objects : instanceListeners.values()) {</span>
<span class="nc" id="L381">                instances.addAll(objects);</span>
<span class="nc" id="L382">            }</span>
<span class="nc" id="L383">            listeners.addAll(instances);</span>
<span class="nc" id="L384">        }</span>

<span class="nc" id="L386">        synchronized (functionalListeners) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            for (List&lt;Object&gt; objects : functionalListeners.values()) {</span>
<span class="nc" id="L388">                listeners.addAll(objects);</span>
<span class="nc" id="L389">            }</span>
<span class="nc" id="L390">        }</span>

<span class="nc" id="L392">        return unmodifiableCollection(listeners);</span>
    }

    @Nonnull
    @Override
    public Collection&lt;Object&gt; getEventListeners(@Nonnull String eventName) {
<span class="nc" id="L398">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="nc" id="L399">        List&lt;Object&gt; listeners = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L400">        List&lt;Object&gt; instances = instanceListeners.get(eventName);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (instances != null) listeners.addAll(instances);</span>
<span class="nc" id="L402">        instances = functionalListeners.get(eventName);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (instances != null) listeners.addAll(instances);</span>
<span class="nc" id="L404">        return unmodifiableCollection(listeners);</span>
    }

    protected Runnable buildPublisher(@Nonnull final String event, @Nonnull final List&lt;?&gt; params, @Nonnull final String mode) {
<span class="fc" id="L408">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="fc" id="L409">        requireNonNull(params, ERROR_PARAMS_NULL);</span>
<span class="fc" id="L410">        requireNonBlank(mode, ERROR_MODE_BLANK);</span>
<span class="fc" id="L411">        return new Runnable() {</span>
            public void run() {
<span class="fc" id="L413">                String eventName = capitalize(event);</span>
<span class="fc" id="L414">                LOG.debug(&quot;Triggering event '{}' {}&quot;, eventName, mode);</span>
<span class="fc" id="L415">                String eventHandler = &quot;on&quot; + eventName;</span>
                // defensive copying to avoid CME during event dispatching
<span class="fc" id="L417">                List&lt;Object&gt; listenersCopy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L418">                List&lt;Object&gt; instances = instanceListeners.get(eventName);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if (instances != null) {</span>
<span class="fc" id="L420">                    listenersCopy.addAll(instances);</span>
                }
<span class="fc" id="L422">                synchronized (functionalListeners) {</span>
<span class="fc" id="L423">                    List list = functionalListeners.get(eventName);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">                    if (list != null) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                        for (Object listener : list) {</span>
<span class="fc" id="L426">                            listenersCopy.add(listener);</span>
<span class="fc" id="L427">                        }</span>
                    }
<span class="pc" id="L429">                }</span>

<span class="fc bfc" id="L431" title="All 2 branches covered.">                for (Object listener : listenersCopy) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                    if (listener instanceof RunnableWithArgs) {</span>
<span class="fc" id="L433">                        fireEvent((RunnableWithArgs) listener, params);</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">                    } else if (listener instanceof CallableWithArgs) {</span>
<span class="nc" id="L435">                        fireEvent((CallableWithArgs&lt;?&gt;) listener, params);</span>
                    } else {
<span class="fc" id="L437">                        fireEvent(listener, eventHandler, params);</span>
                    }
<span class="fc" id="L439">                }</span>
<span class="fc" id="L440">            }</span>
        };
    }

    protected boolean removeNestedListeners(@Nonnull Object owner) {
<span class="fc" id="L445">        requireNonNull(owner, ERROR_OWNER_NULL);</span>

<span class="fc" id="L447">        boolean removed = false;</span>
<span class="fc" id="L448">        synchronized (functionalListeners) {</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            for (Map.Entry&lt;String, List&lt;Object&gt;&gt; event : functionalListeners.entrySet()) {</span>
<span class="fc" id="L450">                String eventName = event.getKey();</span>
<span class="fc" id="L451">                List&lt;Object&gt; listenerList = event.getValue();</span>
<span class="fc" id="L452">                List&lt;Object&gt; toRemove = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                for (Object listener : listenerList) {</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">                    if (isNestedListener(listener, owner)) {</span>
<span class="nc" id="L455">                        toRemove.add(listener);</span>
                    }
<span class="fc" id="L457">                }</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                removed = toRemove.size() &gt; 0;</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">                for (Object listener : toRemove) {</span>
<span class="nc" id="L460">                    LOG.debug(&quot;Removing listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="nc" id="L461">                    listenerList.remove(listener);</span>
<span class="nc" id="L462">                }</span>
<span class="fc" id="L463">            }</span>
<span class="pc" id="L464">        }</span>

<span class="fc" id="L466">        return removed;</span>
    }

    protected boolean isNestedListener(@Nonnull Object listener, @Nonnull Object owner) {
<span class="fc" id="L470">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L471">        requireNonNull(owner, ERROR_OWNER_NULL);</span>
<span class="fc" id="L472">        Class&lt;?&gt; listenerClass = listener.getClass();</span>
<span class="pc bpc" id="L473" title="2 of 6 branches missed.">        return (listenerClass.isMemberClass() || listenerClass.isAnonymousClass() || listenerClass.isLocalClass()) &amp;&amp;</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            owner.getClass().equals(listenerClass.getEnclosingClass()) &amp;&amp;</span>
<span class="pc bnc" id="L475" title="All 2 branches missed.">            owner.equals(GriffonClassUtils.getFieldValue(listener, &quot;this$0&quot;));</span>
    }

    protected Object[] asArray(@Nonnull List&lt;?&gt; list) {
<span class="fc" id="L479">        return list.toArray(new Object[list.size()]);</span>
    }

<span class="fc" id="L482">    protected static class MethodCache {</span>
<span class="fc" id="L483">        private final Map&lt;Class&lt;?&gt;, Map&lt;String, List&lt;MethodInfo&gt;&gt;&gt; methodMap = new ConcurrentHashMap&lt;&gt;();</span>

        public boolean isEventListener(@Nonnull Class&lt;?&gt; klass) {
<span class="fc" id="L486">            Map&lt;String, List&lt;MethodInfo&gt;&gt; methodMetadata = methodMap.get(klass);</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">            if (methodMetadata == null) {</span>
<span class="fc" id="L488">                methodMetadata = fetchMethodMetadata(klass);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                if (!methodMetadata.isEmpty()) {</span>
<span class="fc" id="L490">                    methodMap.put(klass, methodMetadata);</span>
                } else {
<span class="fc" id="L492">                    methodMetadata = null;</span>
                }
            }
<span class="fc bfc" id="L495" title="All 2 branches covered.">            return methodMetadata != null;</span>
        }

        @Nullable
        public Method findMatchingMethodFor(@Nonnull Class&lt;?&gt; klass, @Nonnull MethodDescriptor target) {
<span class="fc" id="L500">            Map&lt;String, List&lt;MethodInfo&gt;&gt; methodMetadata = methodMap.get(klass);</span>

<span class="fc" id="L502">            List&lt;MethodInfo&gt; descriptors = methodMetadata.get(target.getName());</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            if (descriptors != null) {</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">                for (MethodInfo info : descriptors) {</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">                    if (info.descriptor.matches(target)) {</span>
<span class="fc" id="L506">                        return info.method;</span>
                    }
<span class="nc" id="L508">                }</span>
            }

<span class="nc" id="L511">            return null;</span>
        }

        private Map&lt;String, List&lt;MethodInfo&gt;&gt; fetchMethodMetadata(Class&lt;?&gt; klass) {
<span class="fc" id="L515">            Map&lt;String, List&lt;MethodInfo&gt;&gt; methodMetadata = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L517" title="All 2 branches covered.">            for (Method method : klass.getMethods()) {</span>
<span class="fc" id="L518">                MethodDescriptor descriptor = MethodDescriptor.forMethod(method);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                if (GriffonClassUtils.isEventHandler(descriptor)) {</span>
<span class="fc" id="L520">                    String methodName = method.getName();</span>
<span class="fc" id="L521">                    List&lt;MethodInfo&gt; descriptors = methodMetadata.get(methodName);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                    if (descriptors == null) {</span>
<span class="fc" id="L523">                        descriptors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L524">                        methodMetadata.put(methodName, descriptors);</span>
                    }
<span class="fc" id="L526">                    descriptors.add(new MethodInfo(descriptor, method));</span>
                }
            }

<span class="fc" id="L530">            return methodMetadata;</span>
        }
    }

    protected static class MethodInfo {
        private final MethodDescriptor descriptor;
        private final Method method;

<span class="fc" id="L538">        public MethodInfo(MethodDescriptor descriptor, Method method) {</span>
<span class="fc" id="L539">            this.descriptor = descriptor;</span>
<span class="fc" id="L540">            this.method = method;</span>
<span class="fc" id="L541">        }</span>

        public MethodDescriptor getDescriptor() {
<span class="nc" id="L544">            return descriptor;</span>
        }

        public Method getMethod() {
<span class="nc" id="L548">            return method;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>