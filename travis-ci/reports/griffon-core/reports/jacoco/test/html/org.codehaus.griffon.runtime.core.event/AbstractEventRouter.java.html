<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractEventRouter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">griffon-core</a> &gt; <a href="index.source.html" class="el_package">org.codehaus.griffon.runtime.core.event</a> &gt; <span class="el_source">AbstractEventRouter.java</span></div><h1>AbstractEventRouter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.codehaus.griffon.runtime.core.event;

import griffon.core.CallableWithArgs;
import griffon.core.RunnableWithArgs;
import griffon.core.event.Event;
import griffon.core.event.EventRouter;
import griffon.util.GriffonClassUtils;
import griffon.util.MethodDescriptor;
import griffon.util.MethodUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static griffon.util.GriffonClassUtils.convertToTypeArray;
import static griffon.util.GriffonNameUtils.capitalize;
import static griffon.util.GriffonNameUtils.requireNonBlank;
import static java.util.Arrays.asList;
import static java.util.Collections.EMPTY_LIST;
import static java.util.Collections.synchronizedList;
import static java.util.Objects.requireNonNull;

/**
 * @author Andres Almiray
 */
<span class="fc" id="L48">public abstract class AbstractEventRouter implements EventRouter {</span>
<span class="fc" id="L49">    protected static final Object[] LOCK = new Object[0];</span>
    private static final String ERROR_EVENT_NAME_BLANK = &quot;Argument 'eventName' must not be blank&quot;;
    private static final String ERROR_EVENT_HANDLER_BLANK = &quot;Argument 'eventHandler' must not be blank&quot;;
    private static final String ERROR_MODE_BLANK = &quot;Argument 'mode' must not be blank&quot;;
    private static final String ERROR_LISTENER_NULL = &quot;Argument 'listener' must not be null&quot;;
    private static final String ERROR_EVENT_CLASS_NULL = &quot;Argument 'eventClass' must not be null&quot;;
    private static final String ERROR_EVENT_NULL = &quot;Argument 'event' must not be null&quot;;
    private static final String ERROR_CALLABLE_NULL = &quot;Argument 'callable' must not be null&quot;;
    private static final String ERROR_RUNNABLE_NULL = &quot;Argument 'runnable' must not be null&quot;;
    private static final String ERROR_PARAMS_NULL = &quot;Argument 'params' must not be null&quot;;
    private static final String ERROR_INSTANCE_NULL = &quot;Argument 'instance' must not be null&quot;;
    private static final String ERROR_OWNER_NULL = &quot;Argument 'owner' must not be null&quot;;
<span class="fc" id="L61">    private static final Logger LOG = LoggerFactory.getLogger(AbstractEventRouter.class);</span>
<span class="fc" id="L62">    protected final List&lt;Object&gt; instanceListeners = synchronizedList(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L63">    protected final Map&lt;String, List&lt;Object&gt;&gt; functionalListeners = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L64">    private final MethodCache methodCache = new MethodCache();</span>
<span class="fc" id="L65">    private boolean enabled = true;</span>

    @Override
    public boolean isEventPublishingEnabled() {
<span class="fc" id="L69">        synchronized (LOCK) {</span>
<span class="fc" id="L70">            return this.enabled;</span>
<span class="nc" id="L71">        }</span>
    }

    @Override
    public void setEventPublishingEnabled(boolean enabled) {
<span class="fc" id="L76">        synchronized (LOCK) {</span>
<span class="fc" id="L77">            this.enabled = enabled;</span>
<span class="pc" id="L78">        }</span>
<span class="fc" id="L79">    }</span>

    @Override
    public void publishEvent(@Nonnull String eventName) {
<span class="fc" id="L83">        publishEvent(eventName, EMPTY_LIST);</span>
<span class="fc" id="L84">    }</span>

    @Override
    public void publishEvent(@Nonnull String eventName, @Nullable List&lt;?&gt; params) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (!isEventPublishingEnabled()) return;</span>
<span class="fc" id="L89">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (params == null) params = EMPTY_LIST;</span>
<span class="fc" id="L91">        buildPublisher(eventName, params, &quot;synchronously&quot;).run();</span>
<span class="fc" id="L92">    }</span>

    @Override
    public void publishEventOutsideUI(@Nonnull String eventName) {
<span class="fc" id="L96">        publishEventOutsideUI(eventName, EMPTY_LIST);</span>
<span class="fc" id="L97">    }</span>

    @Override
    public void publishEventOutsideUI(@Nonnull String eventName, @Nullable List&lt;?&gt; params) {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (!isEventPublishingEnabled()) return;</span>
<span class="fc" id="L102">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (params == null) params = EMPTY_LIST;</span>
<span class="fc" id="L104">        final Runnable publisher = buildPublisher(eventName, params, &quot;outside UI&quot;);</span>
<span class="fc" id="L105">        doPublishOutsideUI(publisher);</span>
<span class="fc" id="L106">    }</span>

    protected abstract void doPublishOutsideUI(@Nonnull Runnable publisher);

    @Override
    public void publishEventAsync(@Nonnull String eventName) {
<span class="fc" id="L112">        publishEventAsync(eventName, EMPTY_LIST);</span>
<span class="fc" id="L113">    }</span>

    @Override
    public void publishEventAsync(@Nonnull String eventName, @Nullable List&lt;?&gt; params) {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (!isEventPublishingEnabled()) return;</span>
<span class="fc" id="L118">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (params == null) params = EMPTY_LIST;</span>
<span class="fc" id="L120">        final Runnable publisher = buildPublisher(eventName, params, &quot;asynchronously&quot;);</span>
<span class="fc" id="L121">        doPublishAsync(publisher);</span>
<span class="fc" id="L122">    }</span>

    protected abstract void doPublishAsync(@Nonnull Runnable publisher);

    @Override
    public void publishEvent(@Nonnull Event event) {
<span class="fc" id="L128">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="fc" id="L129">        publishEvent(event.getClass().getSimpleName(), asList(event));</span>
<span class="fc" id="L130">    }</span>

    @Override
    public void publishEventOutsideUI(@Nonnull Event event) {
<span class="fc" id="L134">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="fc" id="L135">        publishEventOutsideUI(event.getClass().getSimpleName(), asList(event));</span>
<span class="fc" id="L136">    }</span>

    @Override
    public void publishEventAsync(@Nonnull Event event) {
<span class="fc" id="L140">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="fc" id="L141">        publishEventAsync(event.getClass().getSimpleName(), asList(event));</span>
<span class="fc" id="L142">    }</span>

    @Override
    public &lt;E extends Event&gt; void removeEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="fc" id="L146">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="fc" id="L147">        removeEventListener(eventClass.getSimpleName(), listener);</span>
<span class="fc" id="L148">    }</span>

    @Override
    public &lt;E extends Event&gt; void removeEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull RunnableWithArgs listener) {
<span class="fc" id="L152">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="fc" id="L153">        removeEventListener(eventClass.getSimpleName(), listener);</span>
<span class="fc" id="L154">    }</span>

    protected void fireEvent(@Nonnull RunnableWithArgs runnable, @Nonnull List&lt;?&gt; params) {
<span class="fc" id="L157">        requireNonNull(runnable, ERROR_RUNNABLE_NULL);</span>
<span class="fc" id="L158">        requireNonNull(params, ERROR_PARAMS_NULL);</span>
<span class="fc" id="L159">        runnable.run(asArray(params));</span>
<span class="fc" id="L160">    }</span>

    protected void fireEvent(@Nonnull CallableWithArgs&lt;?&gt; callable, @Nonnull List&lt;?&gt; params) {
<span class="fc" id="L163">        requireNonNull(callable, ERROR_CALLABLE_NULL);</span>
<span class="fc" id="L164">        requireNonNull(params, ERROR_PARAMS_NULL);</span>
<span class="fc" id="L165">        callable.call(asArray(params));</span>
<span class="fc" id="L166">    }</span>

    protected void fireEvent(@Nonnull Object instance, @Nonnull String eventHandler, @Nonnull List&lt;?&gt; params) {
<span class="fc" id="L169">        requireNonNull(instance, ERROR_INSTANCE_NULL);</span>
<span class="fc" id="L170">        requireNonBlank(eventHandler, ERROR_EVENT_HANDLER_BLANK);</span>
<span class="fc" id="L171">        requireNonNull(params, ERROR_PARAMS_NULL);</span>

<span class="fc" id="L173">        Class[] argTypes = convertToTypeArray(asArray(params));</span>
<span class="fc" id="L174">        MethodDescriptor target = new MethodDescriptor(eventHandler, argTypes);</span>
<span class="fc" id="L175">        Method method = methodCache.findMatchingMethodFor(instance.getClass(), target);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L178">            MethodUtils.invokeSafe(method, instance, asArray(params));</span>
        }
<span class="fc" id="L180">    }</span>

    @Override
    public &lt;E extends Event&gt; void addEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="fc" id="L184">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="fc" id="L185">        addEventListener(eventClass.getSimpleName(), listener);</span>
<span class="fc" id="L186">    }</span>

    @Override
    public &lt;E extends Event&gt; void addEventListener(@Nonnull Class&lt;E&gt; eventClass, @Nonnull RunnableWithArgs listener) {
<span class="fc" id="L190">        requireNonNull(eventClass, ERROR_EVENT_CLASS_NULL);</span>
<span class="fc" id="L191">        addEventListener(eventClass.getSimpleName(), listener);</span>
<span class="fc" id="L192">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void addEventListener(@Nonnull Object listener) {
<span class="fc" id="L197">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (listener instanceof RunnableWithArgs) {</span>
<span class="nc" id="L199">            throw new IllegalArgumentException(&quot;Cannot add an event listener of type &quot; + RunnableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (listener instanceof CallableWithArgs) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;Cannot add an event listener of type &quot; + CallableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (listener instanceof Map) {</span>
<span class="nc" id="L208">            addEventListener((Map) listener);</span>
<span class="nc" id="L209">            return;</span>
        }

<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (!methodCache.isEventListener(listener.getClass())) {</span>
<span class="fc" id="L213">            return;</span>
        }

<span class="fc" id="L216">        synchronized (instanceListeners) {</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">            if (instanceListeners.contains(listener)) return;</span>
            try {
<span class="fc" id="L219">                LOG.debug(&quot;Adding listener {}&quot;, listener);</span>
<span class="nc" id="L220">            } catch (UnsupportedOperationException uoe) {</span>
<span class="nc" id="L221">                LOG.debug(&quot;Adding listener {}&quot;, listener.getClass().getName());</span>
<span class="fc" id="L222">            }</span>
<span class="fc" id="L223">            instanceListeners.add(listener);</span>
<span class="pc" id="L224">        }</span>
<span class="fc" id="L225">    }</span>

    @Override
    public void addEventListener(@Nonnull Map&lt;String, Object&gt; listener) {
<span class="fc" id="L229">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; entry : listener.entrySet()) {</span>
<span class="fc" id="L231">            Object eventHandler = entry.getValue();</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (eventHandler instanceof RunnableWithArgs) {</span>
<span class="fc" id="L233">                addEventListener(entry.getKey(), (RunnableWithArgs) eventHandler);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">            } else if (eventHandler instanceof CallableWithArgs) {</span>
<span class="fc" id="L235">                addEventListener(entry.getKey(), (CallableWithArgs) eventHandler);</span>
            } else {
<span class="nc" id="L237">                throw new IllegalArgumentException(&quot;Unsupported functional event listener &quot; + eventHandler);</span>
            }
<span class="fc" id="L239">        }</span>
<span class="fc" id="L240">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void removeEventListener(@Nonnull Object listener) {
<span class="fc" id="L245">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (listener instanceof RunnableWithArgs) {</span>
<span class="nc" id="L247">            throw new IllegalArgumentException(&quot;Cannot remove an event listener of type &quot; + RunnableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (listener instanceof CallableWithArgs) {</span>
<span class="nc" id="L251">            throw new IllegalArgumentException(&quot;Cannot remove an event listener of type &quot; + CallableWithArgs.class.getName() +</span>
                &quot; because the target event name is missing. &quot; + listener);
        }

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (listener instanceof Map) {</span>
<span class="nc" id="L256">            removeEventListener((Map) listener);</span>
<span class="nc" id="L257">            return;</span>
        }
<span class="fc" id="L259">        synchronized (instanceListeners) {</span>
            try {
<span class="fc" id="L261">                LOG.debug(&quot;Removing listener {}&quot;, listener);</span>
<span class="nc" id="L262">            } catch (UnsupportedOperationException uoe) {</span>
<span class="nc" id="L263">                LOG.debug(&quot;Removing listener {}&quot;, listener.getClass().getName());</span>
<span class="fc" id="L264">            }</span>
<span class="fc" id="L265">            instanceListeners.remove(listener);</span>
<span class="fc" id="L266">            removeNestedListeners(listener);</span>
<span class="pc" id="L267">        }</span>
<span class="fc" id="L268">    }</span>

    @Override
    public void removeEventListener(@Nonnull Map&lt;String, Object&gt; listener) {
<span class="fc" id="L272">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; entry : listener.entrySet()) {</span>
<span class="fc" id="L274">            Object eventHandler = entry.getValue();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">            if (eventHandler instanceof RunnableWithArgs) {</span>
<span class="fc" id="L276">                removeEventListener(entry.getKey(), (RunnableWithArgs) eventHandler);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            } else if (eventHandler instanceof CallableWithArgs) {</span>
<span class="fc" id="L278">                removeEventListener(entry.getKey(), (CallableWithArgs) eventHandler);</span>
            } else {
<span class="nc" id="L280">                throw new IllegalArgumentException(&quot;Unsupported functional event listener &quot; + eventHandler);</span>
            }
<span class="fc" id="L282">        }</span>
<span class="fc" id="L283">    }</span>

    @Override
    public void addEventListener(@Nonnull String eventName, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="fc" id="L287">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="fc" id="L288">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L289">        synchronized (functionalListeners) {</span>
<span class="fc" id="L290">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L292">                list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L293">                functionalListeners.put(capitalize(eventName), list);</span>
            }
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">            if (list.contains(listener)) return;</span>
<span class="fc" id="L296">            LOG.debug(&quot;Adding listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="fc" id="L297">            list.add(listener);</span>
<span class="pc" id="L298">        }</span>
<span class="fc" id="L299">    }</span>

    @Override
    public void addEventListener(@Nonnull String eventName, @Nonnull RunnableWithArgs listener) {
<span class="fc" id="L303">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="fc" id="L304">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L305">        synchronized (functionalListeners) {</span>
<span class="fc" id="L306">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L308">                list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L309">                functionalListeners.put(capitalize(eventName), list);</span>
            }
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            if (list.contains(listener)) return;</span>
<span class="fc" id="L312">            LOG.debug(&quot;Adding listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="fc" id="L313">            list.add(listener);</span>
<span class="pc" id="L314">        }</span>
<span class="fc" id="L315">    }</span>

    @Override
    public void removeEventListener(@Nonnull String eventName, @Nonnull CallableWithArgs&lt;?&gt; listener) {
<span class="fc" id="L319">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="fc" id="L320">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L321">        synchronized (functionalListeners) {</span>
<span class="fc" id="L322">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if (list != null) {</span>
<span class="fc" id="L324">                LOG.debug(&quot;Removing listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="fc" id="L325">                list.remove(listener);</span>
            }
<span class="pc" id="L327">        }</span>
<span class="fc" id="L328">    }</span>

    @Override
    public void removeEventListener(@Nonnull String eventName, @Nonnull RunnableWithArgs listener) {
<span class="fc" id="L332">        requireNonBlank(eventName, ERROR_EVENT_NAME_BLANK);</span>
<span class="fc" id="L333">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L334">        synchronized (functionalListeners) {</span>
<span class="fc" id="L335">            List&lt;Object&gt; list = functionalListeners.get(capitalize(eventName));</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if (list != null) {</span>
<span class="fc" id="L337">                LOG.debug(&quot;Removing listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="fc" id="L338">                list.remove(listener);</span>
            }
<span class="pc" id="L340">        }</span>
<span class="fc" id="L341">    }</span>

    protected Runnable buildPublisher(@Nonnull final String event, @Nonnull final List&lt;?&gt; params, @Nonnull final String mode) {
<span class="fc" id="L344">        requireNonNull(event, ERROR_EVENT_NULL);</span>
<span class="fc" id="L345">        requireNonNull(params, ERROR_PARAMS_NULL);</span>
<span class="fc" id="L346">        requireNonBlank(mode, ERROR_MODE_BLANK);</span>
<span class="fc" id="L347">        return new Runnable() {</span>
            public void run() {
<span class="fc" id="L349">                String eventName = capitalize(event);</span>
<span class="fc" id="L350">                LOG.debug(&quot;Triggering event '{}' {}&quot;, eventName, mode);</span>
<span class="fc" id="L351">                String eventHandler = &quot;on&quot; + eventName;</span>
                // defensive copying to avoid CME during event dispatching
                // GRIFFON-224
<span class="fc" id="L354">                List&lt;Object&gt; listenersCopy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L355">                synchronized (instanceListeners) {</span>
<span class="fc" id="L356">                    listenersCopy.addAll(instanceListeners);</span>
<span class="pc" id="L357">                }</span>
<span class="fc" id="L358">                synchronized (functionalListeners) {</span>
<span class="fc" id="L359">                    List list = functionalListeners.get(eventName);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                    if (list != null) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                        for (Object listener : list) {</span>
<span class="fc" id="L362">                            listenersCopy.add(listener);</span>
<span class="fc" id="L363">                        }</span>
                    }
<span class="pc" id="L365">                }</span>

<span class="fc bfc" id="L367" title="All 2 branches covered.">                for (Object listener : listenersCopy) {</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                    if (listener instanceof RunnableWithArgs) {</span>
<span class="fc" id="L369">                        fireEvent((RunnableWithArgs) listener, params);</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                    } else if (listener instanceof CallableWithArgs) {</span>
<span class="fc" id="L371">                        fireEvent((CallableWithArgs&lt;?&gt;) listener, params);</span>
                    } else {
<span class="fc" id="L373">                        fireEvent(listener, eventHandler, params);</span>
                    }
<span class="fc" id="L375">                }</span>
<span class="fc" id="L376">            }</span>
        };
    }

    protected void removeNestedListeners(@Nonnull Object owner) {
<span class="fc" id="L381">        requireNonNull(owner, ERROR_OWNER_NULL);</span>
<span class="fc" id="L382">        synchronized (functionalListeners) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">            for (Map.Entry&lt;String, List&lt;Object&gt;&gt; event : functionalListeners.entrySet()) {</span>
<span class="fc" id="L384">                String eventName = event.getKey();</span>
<span class="fc" id="L385">                List&lt;Object&gt; listenerList = event.getValue();</span>
<span class="fc" id="L386">                List&lt;Object&gt; toRemove = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                for (Object listener : listenerList) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                    if (isNestedListener(listener, owner)) {</span>
<span class="fc" id="L389">                        toRemove.add(listener);</span>
                    }
<span class="fc" id="L391">                }</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">                for (Object listener : toRemove) {</span>
<span class="fc" id="L393">                    LOG.debug(&quot;Removing listener {} on {}&quot;, listener.getClass().getName(), capitalize(eventName));</span>
<span class="fc" id="L394">                    listenerList.remove(listener);</span>
<span class="fc" id="L395">                }</span>
<span class="fc" id="L396">            }</span>
<span class="pc" id="L397">        }</span>
<span class="fc" id="L398">    }</span>

    protected boolean isNestedListener(@Nonnull Object listener, @Nonnull Object owner) {
<span class="fc" id="L401">        requireNonNull(listener, ERROR_LISTENER_NULL);</span>
<span class="fc" id="L402">        requireNonNull(owner, ERROR_OWNER_NULL);</span>
<span class="fc" id="L403">        Class&lt;?&gt; listenerClass = listener.getClass();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        return listenerClass.isMemberClass() &amp;&amp;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">            listenerClass.getEnclosingClass().equals(owner.getClass()) &amp;&amp;</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">            owner.equals(GriffonClassUtils.getFieldValue(listener, &quot;this$0&quot;));</span>
    }

    protected Object[] asArray(@Nonnull List&lt;?&gt; list) {
<span class="fc" id="L410">        return list.toArray(new Object[list.size()]);</span>
    }

<span class="fc" id="L413">    protected static class MethodCache {</span>
<span class="fc" id="L414">        private final Map&lt;Class&lt;?&gt;, Map&lt;String, List&lt;MethodInfo&gt;&gt;&gt; methodMap = new ConcurrentHashMap&lt;&gt;();</span>

        public boolean isEventListener(@Nonnull Class&lt;?&gt; klass) {
<span class="fc" id="L417">            Map&lt;String, List&lt;MethodInfo&gt;&gt; methodMetadata = methodMap.get(klass);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (methodMetadata == null) {</span>
<span class="fc" id="L419">                methodMetadata = fetchMethodMetadata(klass);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">                if (!methodMetadata.isEmpty()) {</span>
<span class="fc" id="L421">                    methodMap.put(klass, methodMetadata);</span>
                } else {
<span class="fc" id="L423">                    methodMetadata = null;</span>
                }
            }
<span class="fc bfc" id="L426" title="All 2 branches covered.">            return methodMetadata != null;</span>
        }

        @Nullable
        public Method findMatchingMethodFor(@Nonnull Class&lt;?&gt; klass, @Nonnull MethodDescriptor target) {
<span class="fc" id="L431">            Map&lt;String, List&lt;MethodInfo&gt;&gt; methodMetadata = methodMap.get(klass);</span>

<span class="fc" id="L433">            List&lt;MethodInfo&gt; descriptors = methodMetadata.get(target.getName());</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (descriptors != null) {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">                for (MethodInfo info : descriptors) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">                    if (info.descriptor.matches(target)) {</span>
<span class="fc" id="L437">                        return info.method;</span>
                    }
<span class="fc" id="L439">                }</span>
            }

<span class="fc" id="L442">            return null;</span>
        }

        private Map&lt;String, List&lt;MethodInfo&gt;&gt; fetchMethodMetadata(Class&lt;?&gt; klass) {
<span class="fc" id="L446">            Map&lt;String, List&lt;MethodInfo&gt;&gt; methodMetadata = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L448" title="All 2 branches covered.">            for (Method method : klass.getMethods()) {</span>
<span class="fc" id="L449">                MethodDescriptor descriptor = MethodDescriptor.forMethod(method);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                if (GriffonClassUtils.isEventHandler(descriptor)) {</span>
<span class="fc" id="L451">                    String methodName = method.getName();</span>
<span class="fc" id="L452">                    List&lt;MethodInfo&gt; descriptors = methodMetadata.get(methodName);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                    if (descriptors == null) {</span>
<span class="fc" id="L454">                        descriptors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L455">                        methodMetadata.put(methodName, descriptors);</span>
                    }
<span class="fc" id="L457">                    descriptors.add(new MethodInfo(descriptor, method));</span>
                }
            }

<span class="fc" id="L461">            return methodMetadata;</span>
        }
    }

    protected static class MethodInfo {
        private final MethodDescriptor descriptor;
        private final Method method;

<span class="fc" id="L469">        public MethodInfo(MethodDescriptor descriptor, Method method) {</span>
<span class="fc" id="L470">            this.descriptor = descriptor;</span>
<span class="fc" id="L471">            this.method = method;</span>
<span class="fc" id="L472">        }</span>

        public MethodDescriptor getDescriptor() {
<span class="nc" id="L475">            return descriptor;</span>
        }

        public Method getMethod() {
<span class="nc" id="L479">            return method;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>